/*
  MDText (with conversion from Markdown to RTF)

  Yoshinori Hayakawa
 */

#import "MDText.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#undef PLAIN_TEXT

char* markdown_to_rtf(const char *md);
char* dbg_markdown_to_rtf(const char *md);

@implementation MDText

- initFrame:(NXRect *)fRect
{
    NXRect r = *fRect;
    [super initFrame:fRect];

#ifdef PLAIN_TEXT
    [self setMonoFont:YES];
#else
    [self setMonoFont:NO];
#endif

    [self setBackgroundGray:NX_WHITE];
    [self setOpaque:YES];
    [self notifyAncestorWhenFrameChanged: YES];
    [self setVertResizable:YES];
    [self setHorizResizable:NO]; // <== needs to be NO
    [self setMinSize:&r.size];
    r.size.height = 1.0e30;
    [self setMaxSize:&r.size];
    [self setSelectable:YES] ;
    [self setEditable:NO] ;
    [self setRetainedWhileDrawing:YES] ;

    [self setAutodisplay:YES] ;

    [self initRTF:self] ;

    return self;
}
- initRTF:sender 
{
    NXStream *buffer;
    if((buffer=NXOpenMemory(NULL,0,NX_READWRITE))==NULL) {
        fprintf(stderr,"Can't open Memory File\n");
        return self;
    }
#ifdef KANJI
    NXPrintf(buffer,"{\\rtf0\\ansi\\deff0{\\fonttbl{{\\f0\\fnil GothicBBBHelvetica;}{\\f1\\fnil FixedGothicBBBCourier;}}}\n") ;
#else
    NXPrintf(buffer,"{\\rtf0\\ansi\\deff0{\\fonttbl{{\\f0\\fnil Helvetica;}{\\f1\\fnil Courier;}}}\n") ;
#endif
    NXPrintf(buffer,"\\pard\\tx250\\tx500\\tx750\\tx1000\\tx1250\\tx1500\\tx1750\\tx2000\\tx2250\\tx2500"
             "\\f0\\b0\\i0\\ulnone\\fs24\\fc0\n") ;
    NXPrintf(buffer,"\\fs24\n") ;
    NXPrintf(buffer,"}\n") ;
    NXSeek(buffer,0L,NX_FROMSTART);
#ifdef PLAIN_TEXT
    [self readText:buffer];
#else
    [self readRichText:buffer];
#endif
    NXCloseMemory(buffer, NX_FREEBUFFER); 
    return self ;
}

- appendAsMarkDown: (char *) md_string
{
    char *rtf ;
    int count ;
    int length ;
    NXStream *buffer;
    if((buffer=NXOpenMemory(NULL,0,NX_READWRITE))==NULL) {
        fprintf(stderr,"Can't open Memory File\n");
        return self;
    }
#ifdef PLAIN_TEXT    
    [self writeText:buffer];     
#else
    [self writeRichText:buffer]; 
#endif
    NXSeek(buffer,-2L,NX_FROMEND) ;
    rtf = markdown_to_rtf(md_string) ;
    // rtf = dbg_markdown_to_rtf(md_string) ;
    //// fputs(rtf,stdout) ;
    count = strlen(rtf) ;
    NXWrite(buffer, rtf, count) ;
    NXPrintf(buffer,"}\n") ;
    NXSeek(buffer,0L,NX_FROMSTART);
#ifdef PLAIN_TEXT
    [self readText:buffer];
#else
    [self readRichText:buffer];
#endif
    NXFlush(buffer) ;
    NXCloseMemory(buffer, NX_FREEBUFFER); 
    free(rtf) ;

    length = [self byteLength];
    [self setSel:length:length] ;

    [self calcLine] ;
    [self sizeToFit] ;

    [self scrollSelToVisible] ;

    return self ;
}


char* dbg_markdown_to_rtf(const char *md) {
    int i ;
    int length = strlen(md) ;
    char *rtf = (char *) malloc(length+1) ;
    strncpy(rtf,md,length) ;
    for (i=0 ; i<length ;i++) {
        if (rtf[i] == '\\') rtf[i]='$' ;
    }
    rtf[length] = 0 ;
    return rtf ;
}

// Conversion from Markdown to NEXTSTEP RTF
// (Rest of the codes is almost generated by ChatGPT...)

#define INITIAL_BUFFER_SIZE 8192

/* snprintf alternative */
int snprintf(char *dst, size_t size, const char *fmt, ...) {
    int result;
    va_list args;
    char *temp = (char*)malloc(size * 2);
    if (!temp) return 0;
    if (size == 0) { free(temp); return 0; }

    va_start(args, fmt);
    result = vsprintf(temp, fmt, args);
    va_end(args);

    if (result < (int)size - 1) {
        strcpy(dst, temp);
    } else {
        strncpy(dst, temp, size - 1);
        dst[size - 1] = '\0';
    }
    free(temp);
    return result;
}

static const char* skip_spaces(const char *p) {
    while (*p == ' ') ++p;
    return p;
}


static BOOL is_hr_line(const char *p) {
    while (*p == ' ' || *p == '\t') ++p;
    if (strncmp(p, "---", 3)==0 || strncmp(p, "***",3)==0) {
        while (*p=='-'||*p=='*'||*p==' ') ++p;
        return (*p=='\0' || *p=='\n');
    }
    return NO;
}

static void emit_escaped_char(char *rtf, size_t *len, size_t bufsize, char c) {
    if (c=='\\' || c=='{' || c=='}') {
        if (*len+2 < bufsize) {
            rtf[(*len)++]='\\';
            rtf[(*len)++]=c;
        }
    } else {
        if (*len+1 < bufsize) {
            rtf[(*len)++]=c;
        }
    }
}

/*
 * process inline formats (***…***, **…**, *…*) 
 * return the position of marker if succeeded, otherwise return NULL
 */
static const char* process_inline_formatting(const char *p,
                                             char *rtf,
                                             size_t *len,
                                             size_t bufsize) {
    char marker;
    const char *end, *r;
    int tick_count = 0;

    /* 0) inline code span: any number of backticks `…` */
    if (*p == '`') {
        /* 開きバッククォートの本数を数える */
        while (p[tick_count] == '`') {
            tick_count++;
        }
        if (tick_count<=2) {
            /* tick_count 個のバッククォートをデリミタとする */
            end = p + tick_count;
            /* 終端デリミタを探す */
            while (*end && *end != '\n') {
                /* マッチ位置を探す */
                if (strncmp(end, p, tick_count) == 0) {
                    /* 見つかった！ */
                    /* コードフォントに切替 (例: \fn1 は等幅フォント) */
                    *len += snprintf(rtf + *len, bufsize - *len, "\\fn1 ");
                    /* デリミタを除く中身を出力 */
                    for (r = p + tick_count; r < end; ++r) {
                        emit_escaped_char(rtf, len, bufsize, *r);
                    }
                    /* フォントをもとに戻す */
                    *len += snprintf(rtf + *len, bufsize - *len, "\\fn0 ");
                    /* デリミタ長を飛ばした位置を返す */
                    return end + tick_count;
                }
                end++;
            }
            /* 終端が見つからない場合はスパン扱いせずリテラル */
        }
    }

    /* 1) bold+italic: ***text*** or ___text___ */
    if (strncmp(p,"***",3)==0 || strncmp(p,"___",3)==0) {
        marker = *p;  end = p+3;
        while (*end && !(end[0]==marker && end[1]==marker && end[2]==marker)) end++;
        if (*end) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\b\\i ");
            for (r=p+3; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\i0\\b0 ");
            return end+3;
        }
    }

    /* 2) bold: **text** or __text__ */
    if (strncmp(p,"**",2)==0 || strncmp(p,"__",2)==0) {
        marker = *p;  end = p+2;
        while (*end && !(end[0]==marker && end[1]==marker)) end++;
        if (*end) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\b ");
            for (r=p+2; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\b0 ");
            return end+2;
        }
    }

    /* 3) italic: *text* or _text_ (but not ** or __) */
    if (((*p=='*') && strncmp(p,"**",2)!=0) ||
        ((*p=='_') && strncmp(p,"__",2)!=0)) {
        marker = *p;  end = p+1;
        while (*end && *end!=marker) end++;
        if (*end==marker) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\i ");
            for (r=p+1; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\i0 ");
            return end+1;
        }
    }

    return NULL;
}

char* markdown_to_rtf(const char *md) {
    size_t bufsize = INITIAL_BUFFER_SIZE;
    char *rtf = malloc(bufsize);
    size_t len = 0;
    const char *p = md;
    BOOL in_code_block = NO;

    if (!rtf) return NULL;

#if 0
    /* RTF header */
    len += snprintf(rtf + len, bufsize - len,
        "{\\rtf1\\ansi\\deff0"
        "{\\fonttbl{\\f0\\fnil GothicBBBHelvetica;}{\\f1\\fnil FixedGothicBBBHelvetica;}}"
        "\\fs24\\par\n");
#endif

    /* main loop */
    while (*p) {

        /* 1) A backslash outside of a code block must output '\\\\'. */
        if (!in_code_block && *p=='\\') {
            emit_escaped_char(rtf, &len, bufsize, '\\');
            p++;
            continue;
        }

        /* 2) code block */
        if (!in_code_block && (p == md || *(p - 1) == '\n')) {
            const char *t = p;
            /* skip heading spaces */
            while (*t == ' ' || *t == '\t') ++t;
            /* 3 consecutive backquotes */
            if (t[0]=='`' && t[1]=='`' && t[2]=='`') {
                const char *scan = t+3;
                const char *fence_end = NULL;
                fence_end = strstr(scan, "```") ;
                if (fence_end) {
                    in_code_block = YES;
                    p = t + 3;
                    if (*p == '\n') ++p;
                    len += snprintf(rtf + len, bufsize - len, "\\pard\\li360\\fi0\n");
                    continue;
                } else {
                    emit_escaped_char(rtf, &len, bufsize, '`');
                    emit_escaped_char(rtf, &len, bufsize, '`');
                    emit_escaped_char(rtf, &len, bufsize, '`');
                    p = t + 3;
                    continue;
                }
            }
        }

        /* end of code block */
        if (in_code_block) {
            const char *t = p;
            while (*t == ' ' || *t == '\t') ++t;
            if (strncmp(t, "```", 3) == 0) {
                in_code_block = NO;
                p = t + 3;
                if (*p == '\n') ++p;
                len += snprintf(rtf + len, bufsize - len, "\n\\pard\\li360\\fi0\n");
                continue;
            }
        }

        /* 3) heading (#) */
        if (*p == '#' && !in_code_block) {
            int level = 0, font_size;
            const char *newp;
            /* i. count labels */
            while (*p == '#') { level++; p++; }
            p = skip_spaces(p);
            font_size = 36 - level * 2;
            /* ii. change style */
            len += snprintf(rtf + len, bufsize - len,
                            "\\b \\fs%d ", font_size);
            /* iii. text */
            while (*p && *p != '\n') {
                newp = process_inline_formatting(p, rtf, &len, bufsize);
                if (newp) { 
                    p = newp; 
                    continue;
                }
                emit_escaped_char(rtf, &len, bufsize, *p++);
            }
            /* iv. reset style */
            len += snprintf(rtf + len, bufsize - len,
                            "\\b0\\fs24\\par\n");
            if (*p == '\n') p++;
            continue;
        }

        /* 4) horizontal line (--- or ***) */
        if (!in_code_block && is_hr_line(p)) {
            len += snprintf(rtf + len, bufsize - len,
                            "──────────────\\par\n");
            while (*p && *p!='\n') p++;
            if (*p=='\n') p++;
            continue;
        }
        /* 5) list items */
        if (!in_code_block &&
            ((*p=='-'||*p=='*') && (p[1]==' '||p[1]=='\t')))
        {
            len += snprintf(rtf + len, bufsize - len, "\\pard\\li360\\fi0 ");
            p += 2;  p = skip_spaces(p);
            while (*p && *p!='\n') {
                const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
                if (newp) {
                    p = newp;
                    continue;
                }
                /* If there is no end marker, process_inline_formatting will return NULL, 
                   so both * and _ will be output as literals by the subsequent emit_escaped_char().*/
                emit_escaped_char(rtf, &len, bufsize, *p++);
            }
            len += snprintf(rtf + len, bufsize - len, "\\par\\pard\\li0\\fi0\n");
            if (*p=='\n') p++;
            continue;
        }
        /* 5) numbered list item */
        if (!in_code_block && (*p>='0'&&*p<='9')) {
            const char *q=p;
            while (*q>='0'&&*q<='9') q++;
            if (*q=='.'&&(q[1]==' '||q[1]=='\t')) {
                int num = atoi(p);
                len += snprintf(rtf + len, bufsize - len, "\\pard\\li300\\fi0 %d. ", num);
                p = q+1;  p = skip_spaces(p);
                while (*p && *p!='\n') {
                    const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
                    if (newp) {
                        p = newp;
                        continue;
                    }
                    /* If there is no end marker, process_inline_formatting will return NULL, 
                       so both * and _ will be output as literals by the subsequent emit_escaped_char().*/
                    emit_escaped_char(rtf, &len, bufsize, *p++);
                }
                len += snprintf(rtf + len, bufsize - len, "\\par\\pard\\li0\\fi0\n");
                if (*p=='\n') p++;
                continue;
            }
        }

        /* 7) inline format (bold/italic) */
        if (!in_code_block) {
            const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
            if (newp) { p=newp; continue; }
        }

        /* 8) code block (raw text) */
        if (in_code_block) {
            while (*p && *p!='\n')
                emit_escaped_char(rtf, &len, bufsize, *p++);
            len += snprintf(rtf + len, bufsize - len, "\\line\n");
            if (*p=='\n') p++;
            continue;
        }

        /* 9) new line (\line) */
        if (*p=='\n') {
            len += snprintf(rtf + len, bufsize - len, "\\line\n");
            p++;
            continue;
        }

        /* 10) other characters */
        emit_escaped_char(rtf, &len, bufsize, *p++);

        if (len > bufsize/2) {
            bufsize *= 2;
            rtf = realloc(rtf, bufsize);
            if (!rtf) {
                fprintf(stderr,"REALLOC FAILED\n") ;
                return NULL;
            }
        }
    }
    /* end of document */
#if 0
    len += snprintf(rtf + len, bufsize - len, "}\n");
#else
    len += snprintf(rtf + len, bufsize - len, "\n");
#endif
    return rtf;
}

@end
