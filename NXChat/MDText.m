/*
  MDText (with conversion from Markdown to RTF)

  Yoshinori Hayakawa
 */

#import "MDText.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#undef PLAIN_TEXT

char* markdown_to_rtf(const char *md);
char* dbg_markdown_to_rtf(const char *md);

@implementation MDText

- initFrame:(NXRect *)fRect
{
    NXRect r = *fRect;
    [super initFrame:fRect];

#ifdef PLAIN_TEXT
    [self setMonoFont:YES];
#else
    [self setMonoFont:NO];
#endif

    [self setBackgroundGray:NX_WHITE];
    [self setOpaque:YES];
    [self notifyAncestorWhenFrameChanged: YES];
    [self setVertResizable:YES];
    [self setHorizResizable:YES];
    [self setMinSize:&r.size];
    r.size.height = 1.0e30;
    [self setMaxSize:&r.size];
    [self setSelectable:YES] ;
    [self setEditable:NO] ;
    [self setRetainedWhileDrawing:YES] ;

    [self initRTF:self] ;

    return self;
}
- initRTF:sender 
{
    NXStream *buffer;
    if((buffer=NXOpenMemory(NULL,0,NX_READWRITE))==NULL) {
        fprintf(stderr,"Can't open Memory File\n");
        return self;
    }
#ifdef KANJI
    NXPrintf(buffer,"{\\rtf0\\ansi\\deff0{\\fonttbl{\\f0\\fnil GothicBBBHelvetica;}}\n") ;
#else
    NXPrintf(buffer,"{\\rtf0\\ansi\\deff0{\\fonttbl{\\f0\\fnil Helvetica;}}\n") ;
#endif
    NXPrintf(buffer,"\\pard\\tx250\\tx500\\tx750\\tx1000\\tx1250\\tx1500\\tx1750\\tx2000\\tx2250\\tx2500"
             "\\f0\\b0\\i0\\ulnone\\fs24\\fc0\n") ;
    NXPrintf(buffer,"\\fs24\n") ;
    NXPrintf(buffer,"}\n") ;
    NXSeek(buffer,0L,NX_FROMSTART);
#ifdef PLAIN_TEXT
    [self readText:buffer];
#else
    [self readRichText:buffer];
#endif
    NXCloseMemory(buffer, NX_FREEBUFFER); 
    return self ;
}

- appendAsMarkDown: (char *) md_string
{
    char *rtf ;
    int count ;
    int length ;
    NXStream *buffer;
    if((buffer=NXOpenMemory(NULL,0,NX_READWRITE))==NULL) {
        fprintf(stderr,"Can't open Memory File\n");
        return self;
    }
#ifdef PLAIN_TEXT    
    [self writeText:buffer];     
#else
    [self writeRichText:buffer]; 
#endif
    NXSeek(buffer,-2L,NX_FROMEND) ;
    rtf = markdown_to_rtf(md_string) ;
    // rtf = dbg_markdown_to_rtf(md_string) ;
    count = strlen(rtf) ;
    NXWrite(buffer, rtf, count) ;
    NXPrintf(buffer,"}\n") ;
    NXFlush(buffer) ;
    NXSeek(buffer,0L,NX_FROMSTART);
#ifdef PLAIN_TEXT
    [self readText:buffer];
#else
    [self readRichText:buffer];
#endif
    NXCloseMemory(buffer, NX_FREEBUFFER); 
    free(rtf) ;

    length = [self byteLength];
    [self setSel:length:length] ;

    [self sizeToFit] ;

    return self ;
}


char* dbg_markdown_to_rtf(const char *md) {
    int i ;
    int length = strlen(md) ;
    char *rtf = (char *) malloc(length+1) ;
    strncpy(rtf,md,length) ;
    for (i=0 ; i<length ;i++) {
        if (rtf[i] == '\\') rtf[i]=' ' ;
    }
    rtf[length] = 0 ;
    return rtf ;
}


// Conversion from Markdown to NEXTSTEP RTF
// (Rest of the codes is almost generated by ChatGPT...)

#define INITIAL_BUFFER_SIZE 8192

/* snprintf の互換実装 */
int snprintf(char *dst, size_t size, const char *fmt, ...) {
    int result;
    va_list args;
    char *temp = (char*)malloc(size * 2);
    if (!temp) return 0;
    if (size == 0) { free(temp); return 0; }

    va_start(args, fmt);
    result = vsprintf(temp, fmt, args);
    va_end(args);

    if (result < (int)size - 1) {
        strcpy(dst, temp);
    } else {
        strncpy(dst, temp, size - 1);
        dst[size - 1] = '\0';
    }
    free(temp);
    return result;
}

/* 空白スキップ */
static const char* skip_spaces(const char *p) {
    while (*p == ' ') ++p;
    return p;
}

/* 水平線判定 */
static BOOL is_hr_line(const char *p) {
    while (*p == ' ' || *p == '\t') ++p;
    if (strncmp(p, "---", 3)==0 || strncmp(p, "***",3)==0) {
        while (*p=='-'||*p=='*'||*p==' ') ++p;
        return (*p=='\0' || *p=='\n');
    }
    return NO;
}

/* RTF特殊文字のエスケープ */
static void emit_escaped_char(char *rtf, size_t *len, size_t bufsize, char c) {
    if (c=='\\' || c=='{' || c=='}') {
        if (*len+2 < bufsize) {
            rtf[(*len)++]='\\';
            rtf[(*len)++]=c;
        }
    } else {
        if (*len+1 < bufsize) {
            rtf[(*len)++]=c;
        }
    }
}

/*
 * インライン書式 (***…***, **…**, *…*) の共通処理
 * 成功すればマーカー末尾の位置、失敗すれば NULL を返す
 */
static const char* process_inline_formatting(const char *p,
                                             char *rtf,
                                             size_t *len,
                                             size_t bufsize) {
    char marker;
    const char *end, *r;

    /* 1) bold+italic: ***text*** or ___text___ */
    if (strncmp(p,"***",3)==0 || strncmp(p,"___",3)==0) {
        marker = *p;  end = p+3;
        while (*end && !(end[0]==marker && end[1]==marker && end[2]==marker)) end++;
        if (*end) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\b\\i ");
            for (r=p+3; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\i0\\b0 ");
            return end+3;
        }
    }

    /* 2) bold: **text** or __text__ */
    if (strncmp(p,"**",2)==0 || strncmp(p,"__",2)==0) {
        marker = *p;  end = p+2;
        while (*end && !(end[0]==marker && end[1]==marker)) end++;
        if (*end) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\b ");
            for (r=p+2; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\b0 ");
            return end+2;
        }
    }

    /* 3) italic: *text* or _text_ (but not ** or __) */
    if (((*p=='*') && strncmp(p,"**",2)!=0) ||
        ((*p=='_') && strncmp(p,"__",2)!=0)) {
        marker = *p;  end = p+1;
        while (*end && *end!=marker) end++;
        if (*end==marker) {
            *len += snprintf(rtf + *len, bufsize - *len, "\\i ");
            for (r=p+1; r<end; r++) emit_escaped_char(rtf, len, bufsize, *r);
            *len += snprintf(rtf + *len, bufsize - *len, "\\i0 ");
            return end+1;
        }
    }

    return NULL;
}

char* markdown_to_rtf(const char *md) {
    size_t bufsize = INITIAL_BUFFER_SIZE;
    char *rtf = malloc(bufsize);
    size_t len = 0;
    const char *p = md;
    BOOL in_code_block = NO;

    if (!rtf) return NULL;

#if 0
    /* RTF ヘッダ出力 */
    len += snprintf(rtf + len, bufsize - len,
        "{\\rtf1\\ansi\\deff0"
        "{\\fonttbl{\\f0\\fnil Helvetica;}}"
        "\\fs24\\par\n");
#endif
    /* 本文ループ */
    while (*p) {
        /* １）コードブロック外のバックスラッシュは必ず "\\\\" を出力 */
        if (!in_code_block && *p=='\\') {
            emit_escaped_char(rtf, &len, bufsize, '\\');
            p++;
            continue;
        }

        /* ２）コードブロック ``` */
        /*   開始（outside） */
        if (!in_code_block && strncmp(p, "```", 3) == 0) {
            const char *fence_end = strstr(p + 3, "```");
            if (fence_end) {
                in_code_block = YES;
                p += 3;
                if (*p == '\n') p++;
            } else {
                /* 閉じフェンスがない → リテラル扱い */
                emit_escaped_char(rtf, &len, bufsize, '`');
                emit_escaped_char(rtf, &len, bufsize, '`');
                emit_escaped_char(rtf, &len, bufsize, '`');
                p += 3;
            }
            continue;
        }
        /*   終了（inside） */
        if ( in_code_block && strncmp(p, "```", 3) == 0) {
            in_code_block = NO;
            p += 3;
            if (*p == '\n') p++;
            continue;
        }

        /* ３）見出し (#) */
        if (*p == '#' && !in_code_block) {
            int level = 0, font_size;
            const char *newp;
            /* 1) 見出しレベルを数える */
            while (*p == '#') { level++; p++; }
            p = skip_spaces(p);
            font_size = 36 - level * 2;
            /* 2) 見出しスタイル開始 */
            len += snprintf(rtf + len, bufsize - len,
                            "\\b \\fs%d ", font_size);
            /* 3) 見出し本文：インライン書式を適用 */
            while (*p && *p != '\n') {
                newp = process_inline_formatting(p, rtf, &len, bufsize);
                if (newp) { 
                    p = newp; 
                    continue;
                }
                emit_escaped_char(rtf, &len, bufsize, *p++);
            }
            /* 4) 見出しスタイル解除＋段落区切り */
            len += snprintf(rtf + len, bufsize - len,
                            "\\b0\\fs24\\par\n");
            if (*p == '\n') p++;
            continue;
        }

        /* ４）水平線 (--- or ***) */
        if (!in_code_block && is_hr_line(p)) {
            len += snprintf(rtf + len, bufsize - len,
                            "──────────────\\par\n");
            while (*p && *p!='\n') p++;
            if (*p=='\n') p++;
            continue;
        }
        /* ５）箇条書きリスト */
        if (!in_code_block &&
            ((*p=='-'||*p=='*') && (p[1]==' '||p[1]=='\t')))
        {
            len += snprintf(rtf + len, bufsize - len, "\\tab 　 ");
            p += 2;  p = skip_spaces(p);
            while (*p && *p!='\n') {
                const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
                if (newp) {
                    /* 正常にマーカーペアが見つかり、出力済み */
                    p = newp;
                    continue;
                }
                /* 終端マーカーなしなら process_inline_formatting は NULL を返すので、
                   "*" も "_" もそのまま後続の emit_escaped_char() でリテラル出力される */
                emit_escaped_char(rtf, &len, bufsize, *p++);
            }
            len += snprintf(rtf + len, bufsize - len, "\\par\n");
            if (*p=='\n') p++;
            continue;
        }
        /* ６）番号付きリスト */
        if (!in_code_block && (*p>='0'&&*p<='9')) {
            const char *q=p;
            while (*q>='0'&&*q<='9') q++;
            if (*q=='.'&&(q[1]==' '||q[1]=='\t')) {
                int num = atoi(p);
                len += snprintf(rtf + len, bufsize - len, "\\tab %d. ", num);
                p = q+1;  p = skip_spaces(p);
                while (*p && *p!='\n') {
                    const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
                    if (newp) {
                        /* 正常にマーカーペアが見つかり、出力済み */
                        p = newp;
                        continue;
                    }
                    /* 終端マーカーなしなら process_inline_formatting は NULL を返すので、
                       "*" も "_" もそのまま後続の emit_escaped_char() でリテラル出力される */
                    emit_escaped_char(rtf, &len, bufsize, *p++);
                }
                len += snprintf(rtf + len, bufsize - len, "\\par\n");
                if (*p=='\n') p++;
                continue;
            }
        }
        /* ７）インライン書式 (太字/斜体) */
        if (!in_code_block) {
            const char *newp = process_inline_formatting(p, rtf, &len, bufsize);
            if (newp) { p=newp; continue; }
        }
        /* ８）コードブロック中は生テキスト + 改行 */
        if (in_code_block) {
            while (*p && *p!='\n')
                emit_escaped_char(rtf, &len, bufsize, *p++);
            len += snprintf(rtf + len, bufsize - len, "\\line\n");
            if (*p=='\n') p++;
            continue;
        }
        /* ９）改行 → 強制改行 (\line) */
        if (*p=='\n') {
            len += snprintf(rtf + len, bufsize - len, "\\line\n");
            p++;
            continue;
        }
        /* 10）その他文字 */
        emit_escaped_char(rtf, &len, bufsize, *p++);
        if (len > bufsize - 100) {
            bufsize *= 2;
            rtf = realloc(rtf, bufsize);
            if (!rtf) return NULL;
        }
    }
    /* ドキュメント終了 */
#if 0
    len += snprintf(rtf + len, bufsize - len, "}\n");
#else
    len += snprintf(rtf + len, bufsize - len, "\n");
#endif
    return rtf;
}
@end
