// 2025-07-07 Yoshinori Hayakawa
// 
// most of the following code is generated by ChatGPT
//

#include "jconv.h"
#include <bsd/libc.h>

/* 二分探索でコードポイントに対応する EUC-JP バイトを得る */
static int lookup_eucjp(uint32_t code, uint8_t *out1, uint8_t *out2) {
    size_t lo = 0, hi = u2e_table_len;
    while (lo < hi) {
        size_t mid = lo + (hi - lo)/2;
        if (u2e_table[mid].unicode < code)
            lo = mid + 1;
        else
            hi = mid;
    }
    if (lo < u2e_table_len && u2e_table[lo].unicode == code) {
        *out1 = u2e_table[lo].euc1;
        *out2 = u2e_table[lo].euc2;
        return 0;
    }
    return -1;
}

/*─── UTF-16LE → Unicode コードポイント デコーダ ───*/
/*
 * s       : 入力バイト列 (UTF-16LE)
 * len     : バイト長
 * pcode   : 出力するコードポイント
 * out_con : consume したバイト数(2 or 4)
 *
 * 戻り値  : 0 成功, -1 不正なエンコーディング
 */
static int utf16le_decode(const unsigned char *s, size_t len,
                          uint32_t *pcode, size_t *out_con)
{
  uint16_t w1 ;
  if (len < 2) return -1;
  w1 = (uint16_t)(s[0] | (s[1] << 8));
  /* BMP 普通文字 */
  if (w1 < 0xD800 || w1 > 0xDFFF) {
    *pcode     = w1;
    *out_con   = 2;
    return 0;
  }
  /* サロゲートペア */
  if (0xD800 <= w1 && w1 <= 0xDBFF) {
    uint16_t w2 ;
    if (len < 4) return -1;
    w2 = (uint16_t)(s[2] | (s[3] << 8));
    if (w2 < 0xDC00 || w2 > 0xDFFF) return -1;
    *pcode   = 0x10000
      + (((uint32_t)(w1 - 0xD800) << 10)
	 |  (uint32_t)(w2 - 0xDC00));
    *out_con = 4;
    return 0;
  }
  /* 不正な単独ロウサロゲート */
  return -1;
}

/*─── UTF-16LE バイト列→EUC-JP 変換関数 ───*/
/*
 * input    : UTF-16LE バイト列 (NUL 終端不要)
 * in_bytes : input の長さ (バイト)
 * output   : 変換後バッファへのポインタ (malloc される)
 * out_len  : 変換後のバイト長を返す
 *
 * 戻り値   : 0=成功, EILSEQ=UTF-16LE エラー or 未対応文字,
 *             EINVAL=バッファ足りない, ENOMEM=メモリ不足
 */
int utf16le_to_eucjp(const unsigned char *input, size_t in_bytes,
                     unsigned char **output, size_t *out_len)
{
    /* 最悪ケース：全コードが２バイトになると仮定 */
    size_t est = (in_bytes/2)*2 + 1;
    unsigned char *buf = malloc(est);
    size_t i,o ;
    if (!buf) return ENOMEM;

    i = 0 ; o = 0;
    while (i < in_bytes) {
        uint32_t cp;
        size_t consumed;
        if (utf16le_decode(input + i, in_bytes - i, &cp, &consumed) < 0) {
            cp = 0x3000;
            consumed = 2;
        }
        i += consumed;

        if (cp < 0x80) {
            /* ASCII */
            if (o + 1 > est) { free(buf); return EINVAL; }
            buf[o++] = (unsigned char)cp;
        }
        else if (0xFF61 <= cp && cp <= 0xFF9F) {
            /* 半角カナ (SS2) */
            if (o + 2 > est) { free(buf); return EINVAL; }
            buf[o++] = 0x8E;
            buf[o++] = (unsigned char)(cp - 0xFF61 + 0xA1);
        }
        else {
            /* JIS X 0208 第1・2水準 */
            uint8_t b1, b2;
            if (lookup_eucjp(cp, &b1, &b2) < 0) {
                if (o + 2 > est) { free(buf); return EINVAL; }
                buf[o++] = 0xA1;
                buf[o++] = 0xA1;
            } else {
                if (o + 2 > est) { free(buf); return EINVAL; }
                buf[o++] = b1;
                buf[o++] = b2;
            }
        }
    }

    *output = buf;
    *out_len = o;
    return 0;
}

static int utf8_decode(const char *s, size_t len, uint32_t *pcode, size_t *out_consumed) {
    unsigned char c = (unsigned char)s[0];
    if (c < 0x80) {
        *pcode = c;
        *out_consumed = 1;
    } else if ((c & 0xE0) == 0xC0 && len >= 2) {
        *pcode = ((c & 0x1F) << 6) | ((unsigned char)s[1] & 0x3F);
        *out_consumed = 2;
    } else if ((c & 0xF0) == 0xE0 && len >= 3) {
        *pcode = ((c & 0x0F) << 12)
            | (((unsigned char)s[1] & 0x3F) << 6)
            |  ((unsigned char)s[2] & 0x3F);
        *out_consumed = 3;
    } else if ((c & 0xF8) == 0xF0 && len >= 4) {
        *pcode = ((c & 0x07) << 18)
            | (((unsigned char)s[1] & 0x3F) << 12)
            | (((unsigned char)s[2] & 0x3F) << 6)
            |  ((unsigned char)s[3] & 0x3F);
        *out_consumed = 4;
    } else {
        return -1;  /* 不正な UTF-8 */
    }
    return 0;
}


int utf8_to_eucjp(const char *input, size_t in_len, unsigned char **output, size_t *out_len) {
    size_t est_len = in_len * 2 + 1; 
    unsigned char *buf = malloc(est_len);
    size_t i,o ;
    if (!buf) return ENOMEM;

    i = 0 ; o = 0;
    while (i < in_len) {
        uint32_t code;
        size_t consumed;
        if (utf8_decode(input + i, in_len - i, &code, &consumed) < 0) {
            code = 0x3000;
            consumed = 1;
        }
        i += consumed;
    
        if (code < 0x80) {
            /* ASCII はそのまま */
            buf[o++] = (unsigned char)code;
        }
        else if (0xFF61 <= code && code <= 0xFF9F) {
            /* 半角カタカナ: SS2 + (U+FF61→0xA1 … U+FF9F→0xDF) */
            if (o + 2 > est_len) goto e_inval;
            buf[o++] = 0x8E;
            buf[o++] = (unsigned char)(code - 0xFF61 + 0xA1);
        }
        else {
            /* JIS X 0208 (第1・2 水準) */
            uint8_t b1, b2;
            if (lookup_eucjp(code, &b1, &b2) < 0) {
                if (o + 2 > est_len) goto e_inval;
                buf[o++] = 0xA1;
                buf[o++] = 0xA1;
            }else {
                if (o + 2 > est_len) goto e_inval;
                buf[o++] = b1;
                buf[o++] = b2;
            }
        }
    }

    if (o<est_len)
        buf[o++] = '\0' ;
    else
        buf[est_len-1] = '\0' ;
    *output = buf;
    *out_len = o;
    return 0;

 e_inval:
    free(buf);
    return EINVAL;
}


/* EUC-JP バイトペアから Unicode を二分探索で引く */
static int lookup_unicode(uint8_t b1, uint8_t b2, uint32_t *pcode) {
    size_t lo = 0, hi = e2u_table_len;
    uint16_t key = ((uint16_t)b1 << 8) | b2;
    while (lo < hi) {
        size_t mid = lo + (hi - lo)/2;
        uint16_t midkey = ((uint16_t)e2u_table[mid].euc1 << 8) | e2u_table[mid].euc2;
        if (midkey < key)      lo = mid + 1;
        else                    hi = mid;
    }
    if (lo < e2u_table_len &&
        e2u_table[lo].euc1 == b1 &&
        e2u_table[lo].euc2 == b2)
        {
            *pcode = e2u_table[lo].unicode;
            return 0;
        }
    return -1;
}

/*─── 汎用：Unicode→UTF-8 エンコーダ ───*/
static int encode_utf8(uint32_t code, unsigned char *out, size_t *olen) {
    if (code <= 0x7F) {
        out[0] = (unsigned char)code;
        *olen = 1;
    }
    else if (code <= 0x7FF) {
        out[0] = 0xC0 | (code >> 6);
        out[1] = 0x80 | (code & 0x3F);
        *olen = 2;
    }
    else if (code <= 0xFFFF) {
        out[0] = 0xE0 | (code >> 12);
        out[1] = 0x80 | ((code >> 6) & 0x3F);
        out[2] = 0x80 | (code & 0x3F);
        *olen = 3;
    }
    else if (code <= 0x10FFFF) {
        out[0] = 0xF0 | (code >> 18);
        out[1] = 0x80 | ((code >> 12) & 0x3F);
        out[2] = 0x80 | ((code >> 6) & 0x3F);
        out[3] = 0x80 | (code & 0x3F);
        *olen = 4;
    }
    else {
        return -1;
    }
    return 0;
}

/*─── 汎用：Unicode→UTF-16LE エンコーダ ───*/
static int encode_utf16le(uint32_t code, unsigned char *out, size_t *olen) {
    if (code <= 0xFFFF) {
        /* BMP 内 */
        out[0] = (unsigned char)( code        & 0xFF);
        out[1] = (unsigned char)((code >> 8)  & 0xFF);
        *olen   = 2;
    }
    else if (code <= 0x10FFFF) {
        /* サロゲートペア */
        uint32_t cp = code - 0x10000;
        uint16_t hi = 0xD800 | ((cp >> 10) & 0x3FF);
        uint16_t lo = 0xDC00 | ( cp        & 0x3FF);
        out[0] = (unsigned char)( hi        & 0xFF);
        out[1] = (unsigned char)((hi >> 8)  & 0xFF);
        out[2] = (unsigned char)( lo        & 0xFF);
        out[3] = (unsigned char)((lo >> 8)  & 0xFF);
        *olen   = 4;
    }
    else {
        return -1;
    }
    return 0;
}

/*─── EUC-JP → UTF-8 変換関数 ───*/
int eucjp_to_utf8(const unsigned char *input, size_t in_len,
                  unsigned char **output, size_t *out_len)
{
    /* 最悪ケース：全て 4 バイト UTF-8 */
    size_t est = in_len * 4 + 1;
    unsigned char *buf = malloc(est);
    size_t i,o ;
    if (!buf) return ENOMEM;

    i = 0 ; o = 0;
    while (i < in_len) {
        uint32_t cp;
        size_t clen;
        /* ASCII */
        if (input[i] < 0x80) {
            cp = input[i++];
        }
        /* SS2 半角カナ */
        else if (input[i] == 0x8E) {
            if (i + 1 >= in_len) { free(buf); return EILSEQ; }
            cp = 0xFF61 + (input[i+1] - 0xA1);
            i += 2;
        }
        /* 2 バイト文字 */
        else {
            if (i + 1 >= in_len) { free(buf); return EILSEQ; }
            if (lookup_unicode(input[i], input[i+1], &cp) < 0) {
                free(buf); return EILSEQ;
            }
            i += 2;
        }

        /* UTF-8 にエンコード */
        if (encode_utf8(cp, buf + o, &clen) < 0 || o + clen > est) {
            free(buf); return EINVAL;
        }
        o += clen;
    }

    *output = buf;
    *out_len = o;
    return 0;
}

/*─── EUC-JP → UTF-16LE 変換関数 ───*/
int eucjp_to_utf16le(const unsigned char *input, size_t in_len,
                     unsigned char **output, size_t *out_len)
{
    /* 最悪ケース：全て 4 バイト UTF-16LE */
    size_t est = in_len * 2 * 2 + 2;
    unsigned char *buf = malloc(est);
    size_t i,o ;
    if (!buf) return ENOMEM;

    i = 0 ; o = 0;
    while (i < in_len) {
        uint32_t cp;
        size_t clen;
        /* ASCII */
        if (input[i] < 0x80) {
            cp = input[i++];
        }
        /* SS2 半角カナ */
        else if (input[i] == 0x8E) {
            if (i + 1 >= in_len) { 
                cp = 0x0020;
                i += 1;
            } else {
                cp = 0xFF61 + (input[i+1] - 0xA1);
                i += 2;
            }
        }
        /* 2 バイト文字 */
        else {
            if (i + 1 >= in_len) { 
                cp = 0x3000;
                i += 1;
            } else {
                if (lookup_unicode(input[i], input[i+1], &cp) < 0) {
                    cp = 0x3000;
                }
                i += 2;
            }
        }
    
        /* UTF-16LE にエンコード */
        if (encode_utf16le(cp, buf + o, &clen) < 0 || o + clen > est) {
            free(buf); return EINVAL;
        }
        o += clen;
    }
  
    *output = buf;
    *out_len = o;
    return 0;
}



